Design Document: Digital Twin Swap SandboxStatus: Draft | Version: 1.0Inspiration: Enode Sandbox Model (Virtual Assets, Instant State Control, Webhook Events)1. Architectural OverviewWe are shifting from a "black box" simulator to an interactive Sandbox Platform. Just as Enode allows developers to instantiate "Virtual Chargers," our system will allow Operations Managers to instantiate "Virtual Cities" and "Virtual Swap Stations" with exposed APIs for real-time manipulation.High-Level ComponentsOrchestrator API (The Gateway): Manages simulation lifecycles and user interactions.Virtual Asset Manager (VAM): [Enode Inspired] Holds the state of every "Digital Twin" (Station, Battery, Vehicle). It allows for manual state overrides (e.g., FORCE_FAIL_CHARGER).Discrete Event Engine (The Brain): Runs the physics and logic (SimPy/AnyLogic). It "listens" to the VAM for configuration and "publishes" events back to it.Telemetry Stream: A WebSocket layer that streams simulation events to the frontend (like Enodeâ€™s webhooks).2. Component Design: "The Virtual Asset Manager"This module directly applies the Enode "Virtual Device" concept.2.1. Asset ClassesInstead of hard-coded rows in a database, every entity is an object with a programmable state.Virtual AssetAttributes (State)Controllable "Interventions" (Methods)Virtual Stationbays_available, queue_length, grid_power_limit.trigger_outage(), .restock_batteries(n), .close_bay(id)Virtual Batterysoc (State of Charge), cycle_count, health_status.force_degrade_health(), .set_soc(val)Virtual Vehiclerider_patience, current_location, urgency.redirect_to_station(id), .cancel_trip()2.2. "God Mode" APIJust as Enode allows testing edge cases (e.g., "Vehicle disconnects before charged"), our API will expose endpoints to force specific states during a running simulation.Endpoint: PATCH /simulation/{sim_id}/assets/station/{station_id}JSON{
  "action": "inject_fault",
  "target": "charger_03",
  "fault_type": "connector_lock_failure",
  "duration_seconds": 1200
}
Why this matters: It allows QA teams to test how the network reacts when a specific station fails, without waiting for a random failure event.3. Simulation Engine ArchitectureThe engine runs in "Virtual Time" but can be paused or stepped for debugging.Core Loop:Fetch: Get current topology and logic from VAM.Execute: Run 15 minutes of simulated time (approx. 200ms real time).Emit: Push state changes (Queue depth +1, Battery SoC +5%) to the Event Bus.Pause Check: If debug_mode is on, pause and wait for user acknowledgment.Isolation Strategy:Uses "Virtual Accounts" (Enode concept).Scenario A and Scenario B run in completely isolated containers.Data is never shared between scenarios, ensuring valid A/B testing.4. Data Model & Persistence (The "History" Feature)Inspired by Enode's "Asset History" for debugging.4.1. The Event LedgerEvery state change is recorded in an append-only log (Time-Series DB like TimescaleDB or InfluxDB).Schema: simulation_eventsSQLtimestamp | sim_id | asset_id   | event_type       | old_value | new_value | meta
----------|--------|------------|------------------|-----------|-----------|------
08:15:00  | sim_99 | station_04 | SWAP_COMPLETED   | 90% SoC   | 100% SoC  | {"wait_time": 120s}
08:15:02  | sim_99 | station_04 | QUEUE_INCREMENT  | 2 cars    | 3 cars    | {"reason": "arrival"}
4.2. "Instant Replay"Because we store the Event Ledger, users can:Run a 24-hour simulation.Spot a spike in wait times at 18:00.Rewind the simulation to 17:55.Inject a new rule (e.g., "Open Reserve Chargers").Re-run from 17:55 to see if the spike is resolved.5. User Interface (UX) MockupThe UI mirrors the "Asset View" from the Enode dashboard.View 1: The "City Sandbox" (Macro)Visual: Map view of the city.Live Metrics: Color-coded stations (Green = OK, Red = High Wait).Controls: A "Time Slider" at the bottom to scrub through the simulation day.View 2: The "Station Inspector" (Micro)Clicking a station zooms in (Like Enode Device Detail).Left Panel: Real-time feed of cars arriving and batteries charging.Right Panel: "Intervention Console."[ Button ] Simulate Power Cut[ Slider ] Adjust Service Speed[ Toggle ] Maintenance Mode6. Implementation Plan (Phased)Phase 1: The "Twin" Core (Weeks 1-4)Build the Virtual Asset Manager classes (Station, Battery).Implement the basic Discrete Event Simulation (DES) loop in Python/SimPy.Create the "Baseline" config loader (Ingest historical CSVs).Phase 2: The API Layer (Weeks 5-6)Wrap the Sim engine in a FastAPI / Flask service.Implement the PATCH /state endpoints for "God Mode" control.Phase 3: The Sandbox UI (Weeks 7-9)Build the Dashboard using React or Streamlit.Integrate the "Instant Replay" slider using the Event Ledger data.7. Comparison: Standard Sim vs. "Enode-Style" SandboxFeatureStandard Simulation ToolOur New "Sandbox" DesignInputStatic CSV files uploaded once.Dynamic API calls; change params while running.Logic"Black Box" (Input -> Wait -> Output)."Glass Box" (Inspect state at any millisecond).DebuggingLogs text files."Asset History" visual timeline.TestingRandom failures based on % chance."Intervention Testing" (Manually trigger specific failures).